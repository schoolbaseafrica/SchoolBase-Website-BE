import * as fs from 'fs';
import { join } from 'path';

import {
  Inject,
  Injectable,
  InternalServerErrorException,
} from '@nestjs/common';
import { WINSTON_MODULE_PROVIDER } from 'nest-winston';
import { DataSource } from 'typeorm';
import { Logger } from 'winston';

import * as sysMsg from '../../constants/system.messages';

import { ConfigureDatabaseDto } from './dto/configure-database.dto';
import { DatabaseModelAction } from './model-actions/database-actions';

@Injectable()
export class DatabaseService {
  private readonly logger: Logger;
  constructor(
    private readonly databaseModelAction: DatabaseModelAction,
    @Inject(WINSTON_MODULE_PROVIDER) baseLogger: Logger,
  ) {
    this.logger = baseLogger.child({ context: DatabaseService.name });
  }

  //===> configure school database <====
  async create(configureDatabaseDto: ConfigureDatabaseDto) {
    // test connection & auto-create tables
    const testConnectionResult =
      await this.testConnectionAndCreateTables(configureDatabaseDto);
    if (!testConnectionResult) {
      this.logger.error(`Attempt to connect and create database failed`);
      throw new InternalServerErrorException(
        sysMsg.DATABASE_CONFIGURATION_FAILED,
      );
    }

    // Save credentials to .env file
    const saveConfigResult = await this.saveConfigToFile(configureDatabaseDto);
    if (!saveConfigResult) {
      this.logger.error(`Attempt to save database configuration failed`);
      throw new InternalServerErrorException(sysMsg.INTERNAL_SERVER_ERROR);
    }

    return {
      message: sysMsg.DATABASE_CONFIGURATION_SUCCESS,
    };
  }

  private async testConnectionAndCreateTables(
    configureDatabaseDto: ConfigureDatabaseDto,
  ) {
    const tempDataSource: DataSource | null = null;

    try {
      const tempDataSource = new DataSource({
        type: configureDatabaseDto.database_type,
        host: configureDatabaseDto.database_host,
        port: configureDatabaseDto.database_port,
        username: configureDatabaseDto.database_username,
        password: configureDatabaseDto.database_password,
        database: configureDatabaseDto.database_name,
        entities: [join(process.cwd(), 'dist', '**', '*.entity.js')],
        synchronize: true,
        logging: false,
        connectTimeoutMS: 10000,
      });

      // Initialize connection
      await tempDataSource.initialize();
      // Verify connection
      await tempDataSource.query('SELECT 1');
      // Close the temporary connection
      await tempDataSource.destroy();

      return true;
    } catch (error) {
      this.logger.error('Database connection failed', { error });
      throw error;
    } finally {
      if (tempDataSource?.isInitialized) {
        await tempDataSource.destroy();
      }
    }
  }

  private async saveConfigToFile(configureDatabaseDto: ConfigureDatabaseDto) {
    const envPath = join(process.cwd(), '.env');

    // Backup existing .env
    if (fs.existsSync(envPath)) {
      fs.copyFileSync(envPath, `${envPath}.setup.backup.${Date.now()}`);
    }
    const escapeEnvValue = (value: string) => {
      if (value.includes(' ') || value.includes('=') || value.includes('"')) {
        return `"${value.replace(/"/g, '\\"')}"`;
      }
      return value;
    };

    try {
      // Read existing .env content if it exists
      let existingEnv = '';
      if (fs.existsSync(envPath)) {
        existingEnv = fs.readFileSync(envPath, 'utf8');
      }

      // Prepare new DB configuration
      const dbConfig = `
      # Database Configuration (Auto-generated by setup)
      DB_TYPE=${escapeEnvValue(configureDatabaseDto.database_type)}
      DB_HOST=${escapeEnvValue(configureDatabaseDto.database_host)}
      DB_PORT=${configureDatabaseDto.database_port}
      DB_USERNAME=${escapeEnvValue(configureDatabaseDto.database_username)}
      DB_PASSWORD=${escapeEnvValue(configureDatabaseDto.database_password)}
      DB_DATABASE=${escapeEnvValue(configureDatabaseDto.database_name)}
      SETUP_COMPLETED='true'
    `.trim();

      // Atomic write (write to temp, then rename)
      const tempPath = `${envPath}.tmp`;
      fs.writeFileSync(tempPath, dbConfig + '\n\n' + existingEnv);
      fs.renameSync(tempPath, envPath);
      return true;
    } catch (error) {
      this.logger.error('Failed to write .env file', { error });
      // restore backup on failure
      const backups = fs
        .readdirSync(process.cwd())
        .filter((f) => f.startsWith('.env.setup.backup.'))
        .sort()
        .reverse();
      if (backups.length > 0) {
        fs.copyFileSync(join(process.cwd(), backups[0]), envPath);
      }
      throw error;
    }
  }
}
